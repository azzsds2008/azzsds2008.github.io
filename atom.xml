<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azzsds2008.github.io</id>
    <title>AnZz &apos; s Blog</title>
    <updated>2020-04-30T02:52:24.176Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://azzsds2008.github.io"/>
    <link rel="self" href="https://azzsds2008.github.io/atom.xml"/>
    <subtitle>风袖翩翩此何处&lt;br/&gt;青林西北雨来时</subtitle>
    <logo>https://azzsds2008.github.io/images/avatar.png</logo>
    <icon>https://azzsds2008.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, AnZz &apos; s Blog</rights>
    <entry>
        <title type="html"><![CDATA[CSS三角强化的巧妙运用]]></title>
        <id>https://azzsds2008.github.io/post/css-san-jiao-qiang-hua-de-qiao-miao-yun-yong/</id>
        <link href="https://azzsds2008.github.io/post/css-san-jiao-qiang-hua-de-qiao-miao-yun-yong/">
        </link>
        <updated>2020-04-22T01:48:15.000Z</updated>
        <content type="html"><![CDATA[<p>实现封面样式的方法如下：</p>
<pre><code class="language-html">&lt;body&gt;
        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;price&quot;&gt;
            &lt;span class=&quot;miaosha&quot;&gt;
                ¥1650
                &lt;i&gt;&lt;/i&gt;
            &lt;/span&gt;
            &lt;span class=&quot;origin&quot;&gt;¥5650&lt;/span&gt;
        &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>css</p>
<pre><code class="language-css">    &lt;style&gt;
         .box1 {
            width: 0;
            height: 0;
            /* 把上边框宽度调大 */
            /* border-top: 100px solid transparent;
            border-right: 50px solid skyblue; */
            /* 左边和下边的边框宽度设置为0 */
            /* border-bottom: 0 solid blue;
            border-left: 0 solid green; */
           /* 1.只保留右边的边框有颜色 */
           border-color: transparent red transparent transparent;
            /* 2. 样式都是solid */
            border-style: solid;
            /* 3. 上边框宽度要大， 右边框 宽度稍小， 其余的边框该为 0 */
            border-width: 100px 50px 0 0 ;

        }
        .price {
            width: 160px;
            height: 24px;
            line-height: 24px;
            border: 1px solid red;
            margin: 0 auto;
        }
        .miaosha {
            position: relative;
            float: left;
            width: 90px;
            height: 100%;
            background-color:red;
            text-align: center;
            color: #fff;
            font-weight: 700;
            margin-right: 8px;

        }
        .miaosha i {
            position: absolute;
            right: 0;
            top: 0;
            width: 0;
            height: 0;
            border-color: transparent #fff transparent transparent;
            border-style: solid;
            border-width: 24px 10px 0 0;
        }
        .origin {
            font-size: 12px;
            color: gray;
            text-decoration: line-through;
        }
    &lt;/style&gt;
    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端 JS 项目开发规范]]></title>
        <id>https://azzsds2008.github.io/post/qian-duan-js-xiang-mu-kai-fa-gui-fan/</id>
        <link href="https://azzsds2008.github.io/post/qian-duan-js-xiang-mu-kai-fa-gui-fan/">
        </link>
        <updated>2020-01-22T01:16:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-编程规约">一、编程规约</h1>
<h3 id="一命名规范">(一)命名规范</h3>
<h4 id="111-项目命名">1.1.1 项目命名</h4>
<p>全部采用小写方式， 以中划线分隔。</p>
<p>正例：<code>mall-management-system</code></p>
<p>反例：<code>mall_management-system / mallManagementSystem</code></p>
<h4 id="112-目录命名">1.1.2 目录命名</h4>
<p>全部采用小写方式， 以中划线分隔，有复数结构时，要采用复数命名法， 缩写不用复数</p>
<p>正例： <code>scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc</code></p>
<p>反例： <code>script / style / demo_scripts / demoStyles / imgs / docs</code></p>
<p>【特殊】VUE 的项目中的 components 中的组件目录，使用 kebab-case 命名</p>
<p>正例： <code>head-search / page-loading / authorized / notice-icon</code></p>
<p>反例： <code>HeadSearch / PageLoading</code></p>
<p>【特殊】VUE 的项目中的除 components 组件目录外的所有目录也使用 kebab-case 命名<br>
正例： <code>page-one / shopping-car / user-management</code></p>
<p>反例： <code>ShoppingCar / UserManagement</code></p>
<h4 id="113-js-css-scss-html-png-文件命名">1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名</h4>
<p>全部采用小写方式， 以中划线分隔</p>
<p>正例： <code>render-dom.js / signup.css / index.html / company-logo.png</code></p>
<p>反例： <code>renderDom.js / UserManagement.html</code></p>
<h4 id="114-命名严谨性">1.1.4 命名严谨性</h4>
<p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用</p>
<p>正例：<code>henan / luoyang / rmb 等国际通用的名称，可视同英文。</code></p>
<p>反例：<code>DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</code></p>
<p><strong>杜绝完全不规范的缩写，避免望文不知义：</strong></p>
<p>反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。</p>
<h3 id="二html-规范-vue-template-同样适用">(二)HTML 规范 （Vue Template 同样适用）</h3>
<h4 id="121-html-类型">1.2.1 HTML 类型</h4>
<p>推荐使用 HTML5 的文档类型申明： <!DOCTYPE html>.<br>
（建议使用 text/html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application/xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。</p>
<ul>
<li>规定字符编码</li>
<li>IE 兼容模式</li>
<li>规定字符编码</li>
<li>doctype 大写</li>
</ul>
<p>正例：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot; /&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;Page title&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot; /&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="122-缩进">1.2.2 缩进</h4>
<p>缩进使用 2 个空格（一个 tab）</p>
<p>嵌套的节点应该缩进。</p>
<h4 id="123-分块注释">1.2.3 分块注释</h4>
<p>在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释。注释格式</p>
<p>&lt;!-- 英文 中文 start &gt;</p>
<p>&lt;!-- 英文 中文 end &gt;<br>
正例：</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;!-- header 头部 start --&gt;
  &lt;header&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;a href=&quot;#&quot;&gt;
        &lt;!-- 图片会把a标签给撑开，所以不用设置a标签的大小 --&gt;
        &lt;img src=&quot;images/header.jpg&quot; /&gt;
      &lt;/a&gt;
    &lt;/div&gt;
  &lt;/header&gt;
  &lt;!-- header 头部 end --&gt;
&lt;/body&gt;
</code></pre>
<h3 id="124-语义化标签">1.2.4 语义化标签</h3>
<p>HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div 或者 p 标签</p>
<p>正例</p>
<pre><code class="language-html">&lt;header&gt;&lt;/header&gt;
&lt;footer&gt;&lt;/footer&gt;
</code></pre>
<p>反例</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<h4 id="125-引号">1.2.5 引号</h4>
<p>使用双引号(&quot; &quot;) 而不是单引号(' ') 。</p>
<p>正例： <code>&lt;div class=&quot;news-div&quot;&gt;&lt;/div&gt;</code></p>
<p>反例： <code>&lt;div class='news-div'&gt;&lt;/div&gt;</code></p>
<h3 id="三-css-规范">(三) CSS 规范</h3>
<h4 id="131-命名">1.3.1 命名</h4>
<ul>
<li>类名使用小写字母，以中划线分隔</li>
<li>id 采用驼峰式命名</li>
<li>scss 中的变量、函数、混合、placeholder 采用驼峰式命名</li>
</ul>
<p>ID 和 class 的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称</p>
<p>不推荐：</p>
<pre><code class="language-css">.fw-800 {
  font-weight: 800;
}

.red {
  color: red;
}
</code></pre>
<p>推荐:</p>
<pre><code>.heavy {
  font-weight: 800;
}

.important {
  color: red;
}
</code></pre>
<h4 id="132-选择器">1.3.2 选择器</h4>
<p>1)css 选择器中避免使用标签名<br>
从结构、表现、行为分离的原则来看，应该尽量避免 css 中出现 HTML 标签，并且在 css 选择器中出现标签名会存在潜在的问题。</p>
<p>2)很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到 DOM 末端的选择器， 你应该总是考虑直接子选择器。</p>
<p>不推荐:</p>
<pre><code class="language-css">.content .title {
  font-size: 2rem;
}
</code></pre>
<p>推荐:</p>
<pre><code class="language-css">.content &gt; .title {
  font-size: 2rem;
}
</code></pre>
<h4 id="133-尽量使用缩写属性">1.3.3 尽量使用缩写属性</h4>
<p>不推荐：</p>
<pre><code class="language-css">border-top-style: none;
font-family: palatino, georgia, serif;
font-size: 100%;
line-height: 1.6;
padding-bottom: 2em;
padding-left: 1em;
padding-right: 1em;
padding-top: 0;
</code></pre>
<p>推荐：</p>
<pre><code class="language-css">border-top: 0;
font: 100%/1.6 palatino, georgia, serif;
padding: 0 1em 2em;
</code></pre>
<h4 id="134-每个选择器及属性独占一行">1.3.4 每个选择器及属性独占一行</h4>
<p>不推荐：</p>
<pre><code>button{
  width:100px;height:50px;color:#fff;background:#00a0e9;
}
</code></pre>
<p>推荐：</p>
<pre><code>button{
  width:100px;
  height:50px;
  color:#fff;
  background:#00a0e9;
}
</code></pre>
<h4 id="135-省略0后面的单位">1.3.5 省略0后面的单位</h4>
<p>不推荐：</p>
<pre><code>div{
  padding-bottom: 0px;
  margin: 0em;
}
</code></pre>
<p>推荐：</p>
<pre><code>div{
  padding-bottom: 0;
  margin: 0;
}
</code></pre>
<h4 id="136-避免使用id选择器及全局标签选择器防止污染全局样式">1.3.6 避免使用ID选择器及全局标签选择器防止污染全局样式</h4>
<p>不推荐：</p>
<pre><code class="language-css">#header{
  padding-bottom: 0px;
  margin: 0em;
}
</code></pre>
<p>推荐：</p>
<pre><code>.header{
  padding-bottom: 0px;
  margin: 0em;
}
</code></pre>
<h3 id="四-less-规范">(四) LESS 规范</h3>
<h4 id="141-代码组织">1.4.1 代码组织</h4>
<h5 id="1将公共less文件放置在stylelesscommon文件夹">1)将公共less文件放置在style/less/common文件夹</h5>
<p>例:// color.less,common.less</p>
<h5 id="2按以下顺序组织">2)按以下顺序组织</h5>
<p>1、@import;<br>
2、变量声明;<br>
3、样式声明;</p>
<pre><code>@import &quot;mixins/size.less&quot;;

@default-text-color: #333;

.page {
  width: 960px;
  margin: 0 auto;
}
</code></pre>
<h4 id="142-避免嵌套层级过多">1.4.2 避免嵌套层级过多</h4>
<p>将嵌套深度限制在3级。对于超过4级的嵌套，给予重新评估。这可以避免出现过于详实的CSS选择器。<br>
避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于20行的嵌套规则出现</p>
<p>不推荐：</p>
<pre><code class="language-less">.main{
  .title{
    .name{
       color:#fff
    }
  }
}
</code></pre>
<p>推荐：</p>
<pre><code>.main-title{
   .name{
      color:#fff
   }
}
</code></pre>
<h3 id="五-javascript-规范">(五) Javascript 规范</h3>
<h4 id="151-命名">1.5.1 命名</h4>
<h5 id="1-采用小写驼峰命名-lowercamelcase代码中的命名均不能以下划线也不能以下划线或美元符号结束">1) 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束</h5>
<p>反例： <code>_name / name_ / name$</code></p>
<h5 id="2-方法名-参数名-成员变量-局部变量都统一使用-lowercamelcase-风格必须遵从驼峰形式">2) 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。</h5>
<p>正例： <code>localValue / getHttpMessage() / inputUserId</code></p>
<p>*<strong>*其中 method 方法命名必须是 动词 或者 动词+名词 形式**</strong></p>
<p>正例：<code>saveShopCarData /openShopCarInfoDialog</code></p>
<p>反例：<code>save / open / show / go</code></p>
<p>*<strong>*特此说明，增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）**</strong></p>
<p><code>add / update / delete / detail / get</code></p>
<p><strong>附： 函数方法常用的动词:</strong></p>
<pre><code class="language-js">get 获取/set 设置,
add 增加/remove 删除
create 创建/destory 移除
start 启动/stop 停止
open 打开/close 关闭,
read 读取/write 写入
load 载入/save 保存,
create 创建/destroy 销毁
begin 开始/end 结束,
backup 备份/restore 恢复
import 导入/export 导出,
split 分割/merge 合并
inject 注入/extract 提取,
attach 附着/detach 脱离
bind 绑定/separate 分离,
view 查看/browse 浏览
edit 编辑/modify 修改,
select 选取/mark 标记
copy 复制/paste 粘贴,
undo 撤销/redo 重做
insert 插入/delete 移除,
add 加入/append 添加
clean 清理/clear 清除,
index 索引/sort 排序
find 查找/search 搜索,
increase 增加/decrease 减少
play 播放/pause 暂停,
launch 启动/run 运行
compile 编译/execute 执行,
debug 调试/trace 跟踪
observe 观察/listen 监听,
build 构建/publish 发布
input 输入/output 输出,
encode 编码/decode 解码
encrypt 加密/decrypt 解密,
compress 压缩/decompress 解压缩
pack 打包/unpack 解包,
parse 解析/emit 生成
connect 连接/disconnect 断开,
send 发送/receive 接收
download 下载/upload 上传,
refresh 刷新/synchronize 同步
update 更新/revert 复原,
lock 锁定/unlock 解锁
check out 签出/check in 签入,
submit 提交/commit 交付
push 推/pull 拉,
expand 展开/collapse 折叠
begin 起始/end 结束,
start 开始/finish 完成
enter 进入/exit 退出,
abort 放弃/quit 离开
obsolete 废弃/depreciate 废旧,
collect 收集/aggregate 聚集
</code></pre>
<h5 id="3-常量命名全部大写单词间用下划线隔开力求语义表达完整清楚不要嫌名字长">3) 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</h5>
<p>正例： <code>MAX_STOCK_COUNT</code></p>
<p>反例： <code>MAX_COUNT</code></p>
<h4 id="152-代码格式">1.5.2 代码格式</h4>
<h5 id="1-使用-2-个空格进行缩进">1) 使用 2 个空格进行缩进</h5>
<p>正例：</p>
<pre><code class="language-js">if (x &lt; y) {
  x += 10;
} else {
  x += 1;
}
</code></pre>
<h5 id="2-不同逻辑-不同语义-不同业务的代码之间插入一个空行分隔开来以提升可读性">2) 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。</h5>
<blockquote>
<p>说明：任何情形，没有必要插入多个空行进行隔开。</p>
</blockquote>
<h4 id="153-字符串">1.5.3 字符串</h4>
<p>统一使用单引号(‘)，不使用双引号(“)。这在创建 HTML 字符串非常有好处：</p>
<p>正例:</p>
<pre><code class="language-js">let str = 'foo';
let testDiv = '&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;';
</code></pre>
<p>反例:</p>
<pre><code class="language-js">let str = 'foo';
let testDiv = &quot;&lt;div id='test'&gt;&lt;/div&gt;&quot;;
</code></pre>
<h4 id="154-对象声明">1.5.4 对象声明</h4>
<h5 id="1使用字面值创建对象">1)使用字面值创建对象</h5>
<p>正例： <code>let user = {};</code></p>
<p>反例： <code>let user = new Object();</code></p>
<h5 id="2-使用字面量来代替对象构造器">2) 使用字面量来代替对象构造器</h5>
<p>正例：</p>
<pre><code class="language-js">var user = {
  age: 0,
  name: 1,
  city: 3
};
</code></pre>
<p>反例：</p>
<pre><code class="language-js">var user = new Object();
user.age = 0;
user.name = 0;
user.city = 0;
</code></pre>
<h4 id="155-使用-es67">1.5.5 使用 ES6,7</h4>
<p>必须优先使用 ES6,7 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。</p>
<blockquote>
<p>必须强制使用 ES6, ES7 的新语法，比如箭头函数、await/async ， 解构， let ， for...of 等等</p>
</blockquote>
<h4 id="156-括号">1.5.6 括号</h4>
<p>下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。</p>
<p>正例：</p>
<pre><code class="language-js">if (condition) {
  doSomething();
}
</code></pre>
<p>反例：</p>
<pre><code class="language-js">if (condition) doSomething();
</code></pre>
<h4 id="157-undefined-判断">1.5.7 undefined 判断</h4>
<p>永远不要直接使用 undefined 进行变量判断；使用 typeof 和字符串'undefined'对变量进行判断。</p>
<p>正例：</p>
<pre><code class="language-js">if (typeof person === 'undefined') {
    ...
}
</code></pre>
<p>反例：</p>
<pre><code class="language-js">if (person === undefined) {
    ...
}
</code></pre>
<h4 id="158-条件判断和循环最多三层">1.5.8 条件判断和循环最多三层</h4>
<p>条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三目运算符。如果超过 3 层请抽成函数，并写清楚注释。</p>
<h4 id="159-this-的转换命名">1.5.9 this 的转换命名</h4>
<p>对上下文 this 的引用只能使用'self'来命名</p>
<h4 id="1510-慎用-consolelog">1.5.10 慎用 console.log</h4>
<p>因 console.log 大量使用会有性能问题，所以在非 webpack 项目中谨慎使用 log 功能</p>
<h1 id="二-vue-项目规范">二、Vue 项目规范</h1>
<h3 id="一-vue-编码基础">(一) Vue 编码基础</h3>
<p>vue 项目规范以 Vue 官方规范 （https://cn.vuejs.org/v2/style-guide/） 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。</p>
<blockquote>
<p>请仔仔细细阅读 Vue 官方规范，切记，此为第一步。</p>
</blockquote>
<h4 id="211-组件规范">2.1.1. 组件规范</h4>
<h5 id="1-组件名为多个单词">1) 组件名为多个单词。</h5>
<p>组件名应该始终是多个单词组成（大于等于 2），且命名规范为<code>KebabCase</code>格式。<br>
这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</p>
<p>正例：</p>
<pre><code class="language-js">export default {
  name: 'TodoItem'
  // ...
};
</code></pre>
<p>反例：</p>
<pre><code class="language-js">export default {
  name: 'Todo',
  // ...
}
export default {
  name: 'todo-item',
  // ...
}
</code></pre>
<h5 id="2-组件文件名为-pascal-case-格式">2) 组件文件名为 pascal-case 格式</h5>
<p>正例：</p>
<pre><code>components/
|- my-component.vue
</code></pre>
<p>反例：</p>
<pre><code>components/
|- myComponent.vue
|- MyComponent.vue
</code></pre>
<h5 id="3-基础组件文件名为-base-开头使用完整单词而不是缩写">3) 基础组件文件名为 base 开头，使用完整单词而不是缩写。</h5>
<p>正例：</p>
<pre><code>components/
|- base-button.vue
|- base-table.vue
|- base-icon.vue
</code></pre>
<p>反例：</p>
<pre><code>components/
|- MyButton.vue
|- VueTable.vue
|- Icon.vue
</code></pre>
<h5 id="4-和父组件紧密耦合的子组件应该以父组件名作为前缀命名">4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名</h5>
<p>正例：</p>
<pre><code>components/
|- todo-list.vue
|- todo-list-item.vue
|- todo-list-item-button.vue
|- user-profile-options.vue （完整单词）
</code></pre>
<p>反例：</p>
<pre><code>components/
|- TodoList.vue
|- TodoItem.vue
|- TodoButton.vue
|- UProfOpts.vue （使用了缩写）
</code></pre>
<h5 id="5-在-template-模版中使用组件应使用-pascalcase-模式并且使用自闭合组件">5) 在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件。</h5>
<p>正例：</p>
<pre><code class="language-html">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;
&lt;MyComponent /&gt;
&lt;Row&gt;&lt;table :column=&quot;data&quot;/&gt;&lt;/Row&gt;
</code></pre>
<p>反例：</p>
<pre><code class="language-html">&lt;my-component /&gt; &lt;row&gt;&lt;table :column=&quot;data&quot;/&gt;&lt;/row&gt;
</code></pre>
<h5 id="6-组件的-data-必须是一个函数">6) 组件的 data 必须是一个函数</h5>
<p>当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。</p>
<p>正例：</p>
<pre><code class="language-js">export default {
  data () {
​    return {
​      name: 'jack'
​    }
  }
}
</code></pre>
<p>反例：</p>
<pre><code class="language-js">export default {
  data: {
​    name: 'jack'
  }
}
</code></pre>
<h5 id="7-prop-定义应该尽量详细">7) Prop 定义应该尽量详细</h5>
<ul>
<li>必须使用 camelCase 驼峰命名</li>
<li>必须指定类型</li>
<li>必须加上注释，表明其含义</li>
<li>必须加上 required 或者 default，两者二选其一</li>
<li>如果有业务需要，必须加上 validator 验证</li>
</ul>
<p>正例：</p>
<pre><code class="language-js"> props: {
  // 组件状态，用于控制组件的颜色
   status: {
 ​    type: String,
     required: true,
 ​    validator: function (value) {
 ​      return [
 ​        'succ',
 ​        'info',
 ​        'error'
 ​      ].indexOf(value) !== -1
 ​    }
   },
    // 用户级别，用于显示皇冠个数
   userLevel：{
      type: String,
      required: true
   }
}
</code></pre>
<h5 id="8-为组件样式设置作用域">8) 为组件样式设置作用域</h5>
<p>正例：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;
&lt;/template&gt;

&lt;!-- 使用 `scoped` 特性 --&gt;
&lt;style scoped&gt;
  .btn-close {
    background-color: red;
  }
&lt;/style&gt;
</code></pre>
<p>反例：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;
&lt;/template&gt;
&lt;!-- 没有使用 `scoped` 特性 --&gt;
&lt;style&gt;
  .btn-close {
    background-color: red;
  }
&lt;/style&gt;
</code></pre>
<h5 id="9-如果特性元素较多应该主动换行">9) 如果特性元素较多，应该主动换行。</h5>
<p>正例：</p>
<pre><code class="language-html">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;
    foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;
    foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;
 /&gt;
</code></pre>
<p>反例：</p>
<pre><code class="language-html">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;/&gt;
</code></pre>
<h4 id="212-模板中使用简单的表达式">2.1.2. 模板中使用简单的表达式</h4>
<p>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。</p>
<p>正例：</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;p&gt;{{ normalizedFullName }}&lt;/p&gt;
&lt;/template&gt;

// 复杂表达式已经移入一个计算属性
computed: {
  normalizedFullName: function () {
​    return this.fullName.split(' ').map(function (word) {
​      return word[0].toUpperCase() + word.slice(1)
​    }).join(' ')
  }
}
</code></pre>
<p>反例：</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;p&gt;
       {{
          fullName.split(' ').map(function (word) {
​             return word[0].toUpperCase() + word.slice(1)
           }).join(' ')
        }}
  &lt;/p&gt;
&lt;/template&gt;
</code></pre>
<h4 id="213-指令都使用缩写形式">2.1.3 指令都使用缩写形式</h4>
<p>指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)</p>
<p>正例：</p>
<pre><code class="language-js">&lt;input
  @input=&quot;onInput&quot;
  @focus=&quot;onFocus&quot;
&gt;
</code></pre>
<p>反例：</p>
<pre><code class="language-js">&lt;input
  v-on:input=&quot;onInput&quot;
  @focus=&quot;onFocus&quot;
&gt;

</code></pre>
<h4 id="214-标签顺序保持一致">2.1.4 标签顺序保持一致</h4>
<p>单文件组件应该总是让标签顺序保持为 <code>&lt;template&gt; 、&lt;script&gt;、 &lt;style&gt;</code></p>
<p>正例：</p>
<pre><code class="language-java">&lt;template&gt;...&lt;/template&gt;
&lt;script&gt;...&lt;/script&gt;
&lt;style&gt;...&lt;/style&gt;
</code></pre>
<p>反例：</p>
<pre><code>&lt;template&gt;...&lt;/template&gt;
&lt;style&gt;...&lt;/style&gt;
&lt;script&gt;...&lt;/script&gt;
</code></pre>
<h4 id="215-必须为-v-for-设置键值-key">2.1.5 必须为 v-for 设置键值 key</h4>
<h4 id="216-v-show-与-v-if-选择">2.1.6 v-show 与 v-if 选择</h4>
<p>如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。</p>
<h4 id="217-script-标签内部结构顺序">2.1.7 script 标签内部结构顺序</h4>
<p>components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数（钩子函数按其执行顺序） &gt; methods</p>
<h4 id="218-vue-router-规范">2.1.8 Vue Router 规范</h4>
<h5 id="1-页面跳转数据传递使用路由参数">1) 页面跳转数据传递使用路由参数</h5>
<p>页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。</p>
<p>正例：</p>
<pre><code class="language-js">let id = ' 123';
this.$router.push({ name: 'userCenter', query: { id: id } });
</code></pre>
<h5 id="2-使用路由懒加载延迟加载机制">2) 使用路由懒加载（延迟加载）机制</h5>
<pre><code class="language-js">    {
        path: '/uploadAttachment',
        name: 'uploadAttachment',
        meta: {
          title: '上传附件'
        },
        component: () =&gt; import('@/view/components/uploadAttachment/index.vue')
      },
</code></pre>
<h5 id="3-router-中的命名规范">3) router 中的命名规范</h5>
<p>path、childrenPoints 命名规范采用<code>kebab-case</code>命名规范（尽量vue文件的目录结构保持一致，因为目录、文件名都是<code>kebab-case</code>，这样很方便找到对应的文件）</p>
<p>name 命名规范采用<code>KebabCase</code>命名规范且和component组件名保持一致！（因为要保持keep-alive特性，keep-alive按照component的name进行缓存，所以两者必须高度保持一致）</p>
<pre><code class="language-js">// 动态加载
export const reload = [
  {
    path: '/reload',
    name: 'reload',
    component: Main,
    meta: {
      title: '动态加载',
      icon: 'icon iconfont'
    },

    children: [
      {
        path: '/reload/smart-reload-list',
        name: 'SmartReloadList',
        meta: {
          title: 'SmartReload',
          childrenPoints: [
            {
              title: '查询',
              name: 'smart-reload-search'
            },
            {
              title: '执行reload',
              name: 'smart-reload-update'
            },
            {
              title: '查看执行结果',
              name: 'smart-reload-result'
            }
          ]
        },
        component: () =&gt;
          import('@/views/reload/smart-reload/smart-reload-list.vue')
      }
    ]
  }
];
</code></pre>
<h5 id="4-router-中的-path-命名规范">4) router 中的 path 命名规范</h5>
<p>path除了采用<code>kebab-case</code>命名规范以外，必须以 / 开头，即使是children里的path也要以 / 开头。如下示例</p>
<ul>
<li></li>
</ul>
<p>目的：</p>
<p>经常有这样的场景：某个页面有问题，要立刻找到这个vue文件，如果不用以/开头，path为parent和children组成的，可能经常需要在router文件里搜索多次才能找到，而如果以/开头，则能立刻搜索到对应的组件<br>
*</p>
<pre><code class="language-js">{
    path: '/file',
    name: 'File',
    component: Main,
    meta: {
      title: '文件服务',
      icon: 'ios-cloud-upload'
    },
    children: [
      {
        path: '/file/file-list',
        name: 'FileList',
        component: () =&gt; import('@/views/file/file-list.vue')
      },
      {
        path: '/file/file-add',
        name: 'FileAdd',
        component: () =&gt; import('@/views/file/file-add.vue')
      },
      {
        path: '/file/file-update',
        name: 'FileUpdate',
        component: () =&gt; import('@/views/file/file-update.vue')
      }
    ]
  }
</code></pre>
<h3 id="二-vue-项目目录规范">(二) Vue 项目目录规范</h3>
<h4 id="221-基础">2.2.1 基础</h4>
<p>vue 项目中的所有命名一定要与后端命名统一。</p>
<p>比如权限：后端 privilege, 前端无论 router , store, api 等都必须使用 privielege 单词！</p>
<h4 id="222-使用-vue-cli-脚手架">2.2.2 使用 Vue-cli 脚手架</h4>
<p>使用 vue-cli3 来初始化项目，项目名按照上面的命名规范。</p>
<h4 id="223-目录说明">2.2.3 目录说明</h4>
<p>目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。</p>
<pre><code>src                               源码目录
|-- api                              所有api接口
|-- assets                           静态资源，images, icons, styles等
|-- components                       公用组件
|-- config                           配置信息
|-- constants                        常量信息，项目所有Enum, 全局常量等
|-- directives                       自定义指令
|-- filters                          过滤器，全局工具
|-- datas                            模拟数据，临时存放
|-- lib                              外部引用的插件存放及修改文件
|-- mock                             模拟接口，临时存放
|-- plugins                          插件，全局使用
|-- router                           路由，统一管理
|-- store                            vuex, 统一管理
|-- themes                           自定义样式主题
|-- views                            视图目录
|   |-- role                             role模块名
|   |-- |-- role-list.vue                    role列表页面
|   |-- |-- role-add.vue                     role新建页面
|   |-- |-- role-update.vue                  role更新页面
|   |-- |-- index.less                      role模块样式
|   |-- |-- components                      role模块通用组件文件夹
|   |-- employee                         employee模块
</code></pre>
<h5 id="1-api-目录">1) api 目录</h5>
<ul>
<li>文件、变量命名要与后端保持一致。</li>
<li>此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。</li>
<li>api 中的方法名字要与后端 api url 尽量保持语义高度一致性。</li>
<li>对于 api 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。</li>
</ul>
<p>正例：</p>
<p>后端 url： EmployeeController.java</p>
<pre><code class="language-js">/employee/add
/employee/delete/{id}
/employee/update
</code></pre>
<p>前端： employee.js</p>
<pre><code class="language-js">  // 添加员工
  addEmployee: (data) =&gt; {
    return postAxios('/employee/add', data)
  },
  // 更新员工信息
  updateEmployee: (data) =&gt; {
    return postAxios('/employee/update', data)
  },
    // 删除员工
  deleteEmployee: (employeeId) =&gt; {
    return postAxios('/employee/delete/' + employeeId)
   },
</code></pre>
<h5 id="2-assets-目录">2) assets 目录</h5>
<p>assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case</p>
<pre><code>|assets
|-- icons
|-- images
|   |-- background-color.png
|   |-- upload-header.png
|-- styles
</code></pre>
<h5 id="3-components-目录">3) components 目录</h5>
<p>此目录应按照组件进行目录划分，目录命名为 KebabCase，组件命名规则也为 KebabCase</p>
<pre><code>|components
|-- error-log
|   |-- index.vue
|   |-- index.less
|-- markdown-editor
|   |-- index.vue
|   |-- index.js
|-- kebab-case

</code></pre>
<h5 id="4-constants-目录">4) constants 目录</h5>
<p>此目录存放项目所有常量，如果常量在 vue 中使用，请使用 vue-enum 插件(https://www.npmjs.com/package/vue-enum)</p>
<p>目录结构：</p>
<pre><code>|constants
|-- index.js
|-- role.js
|-- employee.js
</code></pre>
<p>例子： employee.js</p>
<pre><code class="language-js">export const EMPLOYEE_STATUS = {
  NORMAL: {
    value: 1,
    desc: '正常'
  },
  DISABLED: {
    value: 1,
    desc: '禁用'
  },
  DELETED: {
    value: 2,
    desc: '已删除'
  }
};

export const EMPLOYEE_ACCOUNT_TYPE = {
  QQ: {
    value: 1,
    desc: 'QQ登录'
  },
  WECHAT: {
    value: 2,
    desc: '微信登录'
  },
  DINGDING: {
    value: 3,
    desc: '钉钉登录'
  },
  USERNAME: {
    value: 4,
    desc: '用户名密码登录'
  }
};

export default {
  EMPLOYEE_STATUS,
  EMPLOYEE_ACCOUNT_TYPE
};
</code></pre>
<h5 id="5-router-与-store-目录">5) router 与 store 目录</h5>
<p>这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。</p>
<p>router 尽量按照 views 中的结构保持一致</p>
<p>store 按照业务进行拆分不同的 js 文件</p>
<h5 id="6-views-目录">6) views 目录</h5>
<ul>
<li>命名要与后端、router、api 等保持一致</li>
<li>components 中组件要使用 PascalCase 规则</li>
</ul>
<pre><code>|-- views                            视图目录
|   |-- role                             role模块名
|   |   |-- role-list.vue                    role列表页面
|   |   |-- role-add.vue                     role新建页面
|   |   |-- role-update.vue                  role更新页面
|   |   |-- index.less                      role模块样式
|   |   |-- components                      role模块通用组件文件夹
|   |   |   |-- role-header.vue                        role头部组件
|   |   |   |-- role-modal.vue                         role弹出框组件
|   |-- employee                         employee模块
|   |-- behavior-log                      行为日志log模块
|   |-- code-generator                    代码生成器模块
</code></pre>
<h4 id="224-注释说明">2.2.4 注释说明</h4>
<p>整理必须加注释的地方</p>
<ul>
<li>公共组件使用说明</li>
<li>api 目录的接口 js 文件必须加注释</li>
<li>store 中的 state, mutation, action 等必须加注释</li>
<li>vue 文件中的 template 必须加注释，若文件较大添加 start end 注释</li>
<li>vue 文件的 methods，每个 method 必须添加注释</li>
<li>vue 文件的 data, 非常见单词要加注释</li>
</ul>
<h4 id="225-其他">2.2.5 其他</h4>
<h5 id="1-尽量不要手动操作-dom">1) 尽量不要手动操作 DOM</h5>
<p>因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。</p>
<h5 id="2-删除无用代码">2) 删除无用代码</h5>
<p>因使用了 git/svn 等代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用postcss-pxtorem转化 Rem]]></title>
        <id>https://azzsds2008.github.io/post/shi-yong-postcss-pxtorem-zhuan-hua-rem/</id>
        <link href="https://azzsds2008.github.io/post/shi-yong-postcss-pxtorem-zhuan-hua-rem/">
        </link>
        <updated>2020-01-15T05:18:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="rem-适配">Rem 适配</h1>
<p>Vant 中的样式默认使用px作为单位，如果需要使用rem单位，推荐使用以下两个工具：</p>
<ul>
<li>postcss-pxtorem 是一款 postcss 插件，用于将单位转化为 rem</li>
<li>lib-flexible 用于设置 rem 基准值</li>
</ul>
<hr>
<h2 id="postcss-配置">PostCSS 配置</h2>
<p>在安装postcss-pxtorem的时候会生成一个文件.postcssrc.js<br>
下面提供了一份基本的 postcss 配置，可以在此配置的基础上根据项目需求进行修改</p>
<pre><code class="language-js">module.exports = {
  plugins: {
    autoprefixer: {
      browsers: ['Android &gt;= 4.0', 'iOS &gt;= 8'],
    },
    'postcss-pxtorem': {
      rootValue: 37.5,
      propList: ['*'],
    },
  },
};
</code></pre>
<hr>
<p>当配置完之后，只需要重启下服务，就自动转化为rem了</p>
<pre><code>npm run dev
</code></pre>
<blockquote>
<p>注意：在配置 postcss-loader 时，应避免 ignore node_modules 目录，这会导致 Vant 的样&gt; 式无法被编译</p>
</blockquote>
<hr>
<blockquote>
<p>注意：rootValue这个配置项的数值,通常我们是根据设计图来定这个值，原因很简单，便于开发。<br>
假如设计图给的宽度是750，我们通常就会把rootValue设置为75，这样我们写样式时，可以直接按照设&gt; 计图标注的宽高来1:1还原开发。<br>
（iPhone界面尺寸：320 * 480、640 * 960、640 * 1136、750 * 1334、1080 * 1920等。）</p>
</blockquote>
<p>为什么这里写成了37.5?<br>
是为了引用像vant、mint-ui这样的第三方UI框架，因为第三方框架没有兼容rem，用的是px单位，将rootValue的值设置为设计图宽度（这里为750px）75的一半，即可以1:1还原vant、mint-ui的组件，否则会样式会有变化，例如按钮会变小。</p>
<p>lib-flexible和postcss-pxtorem搭配，因为lib-flexible和postcss-pxtorem里面有一个过滤功能，可以让我们过滤掉以van开头的样式：在引入的postcssrc.js里面设置：</p>
<pre><code class="language-js">module.exports={
　　plugins:{
　　　　'postcss-pxtorem':{
　　　　　　rootValue:37.5,
　　　　　　propList:['*'],
　　　　　　selectorBlackList:['van']
　　　　}
　　}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网站TDK标签SEO优化]]></title>
        <id>https://azzsds2008.github.io/post/wang-zhan-tdk-biao-qian-seo-you-hua/</id>
        <link href="https://azzsds2008.github.io/post/wang-zhan-tdk-biao-qian-seo-you-hua/">
        </link>
        <updated>2020-01-08T01:57:14.000Z</updated>
        <content type="html"><![CDATA[<p>SEO:搜索引擎优化；利用搜索引擎的规则提高网站在有关搜索引擎内自然排名的方式<br>
SEO目的是对网站进行深度优化，从而帮助网站获取免费的流量，提升在搜索引擎上的排名，提高知名度<br>
页面必须有三个标签用来符合SEO优化</p>
<h1 id="title-网站标题">title 网站标题</h1>
<p>title 具有不可替代性，是我们内页的第一个重要标签，是搜索引擎了解网页的入口和对网页主题归属的最佳判断点。<br>
建议：网站名（产品名）- 网站的介绍 （尽量不要超过30个汉字）<br>
例如：</p>
<blockquote>
<p>京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！<br>
小米商城 - 小米10 Pro、Redmi K30、小米MIX Alpha，小米电视官方网站</p>
</blockquote>
<h1 id="description-网站说明">description 网站说明</h1>
<p>简要说明我们网站主要是做什么的。<br>
我们提倡，description 作为网站的总体业务和主题概括，多采用“我们是…”、“我们提供…”、“×××网<br>
作为…”、“电话：010…”之类语句。<br>
例如：</p>
<pre><code class="language-HTML">&lt;meta name=&quot;description&quot; content=&quot;京东JD.COM-专业的综合网上购物商城,销售家电、数码通
讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!&quot; /&gt;
</code></pre>
<h1 id="keywords-关键字">keywords 关键字</h1>
<p>keywords 是页面关键词，是搜索引擎的关注点之一。<br>
keywords 最好限制为 6～8 个关键词，关键词之间用英文逗号隔开，采用 关键词1,关键词2 的形式。<br>
例如：</p>
<pre><code class="language-HTML">&lt;meta name= &quot; keywords&quot; content=&quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相
机,数码,配件,手表,存储卡,京东&quot; /&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[小程序,脸部识别]]></title>
        <id>https://azzsds2008.github.io/post/xiao-cheng-xu-lian-bu-shi-bie/</id>
        <link href="https://azzsds2008.github.io/post/xiao-cheng-xu-lian-bu-shi-bie/">
        </link>
        <updated>2020-01-02T04:05:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="动态设置-camera-组件的高度">动态设置 camera 组件的高度</h2>
<ol>
<li>
<p>渲染 camera 组件</p>
<pre><code class="language-xml">&lt;camera style=&quot;height: {{wh}}px; width: 100%;&quot; flash=&quot;off&quot;&gt;&lt;/camera&gt;
</code></pre>
</li>
<li>
<p>在 data 中定义 <code>wh</code></p>
<pre><code class="language-js">data: {
    // 窗口可用的高度
    wh: 0
}
</code></pre>
</li>
<li>
<p>动态获取页面可用高度</p>
<pre><code class="language-js">/**
* 生命周期函数--监听页面加载
*/
onLoad: function(options) {
    const sysInfo = wx.getSystemInfoSync()
    this.setData({
        wh: sysInfo.windowHeight
    })
}
</code></pre>
</li>
</ol>
<h2 id="隐藏-navigation-导航条">隐藏 navigation 导航条</h2>
<p>在 app.json 的 window 节点中，新增如下配置：</p>
<pre><code class="language-json">{
  &quot;pages&quot;: [
    &quot;pages/home/home&quot;
  ],
  &quot;window&quot;: {
    // ... 省略其他配置
    &quot;navigationStyle&quot;: &quot;custom&quot;
  },
  &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;
}
</code></pre>
<h2 id="在-camera-组件之上渲染操作按钮">在 camera 组件之上渲染操作按钮</h2>
<ol>
<li>
<p>定义如下的页面结构：</p>
<pre><code class="language-xml">&lt;camera style=&quot;height: {{wh}}px; width: 100%;&quot; flash=&quot;off&quot;&gt;
  &lt;cover-view class='btn-box'&gt;
    &lt;!-- 切换摄像头 --&gt;
    &lt;cover-image src='/images/icon/reverse.png'&gt;&lt;/cover-image&gt;
    &lt;!-- 拍照 --&gt;
    &lt;cover-image src='/images/icon/camera.png'&gt;&lt;/cover-image&gt;
    &lt;!-- 从相册选取照片 --&gt;
    &lt;cover-image src='/images/icon/album.png'&gt;&lt;/cover-image&gt;
  &lt;/cover-view&gt;
&lt;/camera&gt;
</code></pre>
</li>
<li>
<p>美化样式：</p>
<pre><code class="language-css">.btn-box {
  display: flex;
  justify-content: space-around;
  position: absolute;
  bottom: 50px;
  width: 100%;
}

.btn-box cover-image {
  width: 50px;
  height: 50px;
  opacity: 0.7;
}
</code></pre>
</li>
</ol>
<h2 id="动态切换摄像头朝向">动态切换摄像头朝向</h2>
<ol>
<li>
<p>在 data 中定义数据：</p>
<pre><code class="language-js">data: {
    // 摄像头的朝向   front   back
    position: 'front'
}
</code></pre>
</li>
<li>
<p>为切换摄像头按钮绑定点击事件处理函数：</p>
<pre><code class="language-xml">&lt;!-- 切换摄像头 --&gt;
&lt;cover-image src='/images/icon/reverse.png' bindtap='reverseCamera'&gt;&lt;/cover-image&gt;
</code></pre>
</li>
<li>
<p>实现reverseCamera函数的功能：</p>
<pre><code class="language-js">// 点击按钮，切换摄像头
reverseCamera() {
    const newPosition = this.data.position === 'front' ? 'back' : 'front'
    this.setData({
      position: newPosition
    })
}
</code></pre>
</li>
<li>
<p>为 camera 组件动态绑定 <code>device-position</code></p>
<pre><code class="language-xml">&lt;camera style=&quot;height: {{wh}}px; width: 100%;&quot; flash=&quot;off&quot; device-position='{{position}}'&gt;&lt;/camera&gt;
</code></pre>
</li>
</ol>
<h2 id="实现拍照功能">实现拍照功能</h2>
<ol>
<li>
<p>在 data 中定义数据：</p>
<pre><code class="language-js">data: {
    // 照片的路径
    src: ''
}
</code></pre>
</li>
<li>
<p>为拍照按钮绑定点击事件处理函数：</p>
<pre><code class="language-xml">&lt;!-- 拍照 --&gt;
&lt;cover-image src='/images/icon/camera.png' bindtap='takePhoto'&gt;&lt;/cover-image&gt;
</code></pre>
</li>
<li>
<p>实现 takePhoto 函数的功能：</p>
<pre><code class="language-js">// 拍照
takePhoto() {
    // 创建相机的实例对象
    const ctx = wx.createCameraContext()
    // ctx.takePhoto 实现拍照
    ctx.takePhoto({
      quality: 'high',
      success: (res) =&gt; {
        // console.log(res.tempImagePath)
        this.setData({
          src: res.tempImagePath,
          isShowPic: true
        }, () =&gt; {
          this.getFaceInfo()
        })
      },
      fail: () =&gt; {
        console.log('拍照失败！')
        this.setData({
          src: ''
        })
      }
    })
}
</code></pre>
</li>
</ol>
<h2 id="从相册选取照片">从相册选取照片</h2>
<ol>
<li>
<p>为按钮绑定事件处理函数：</p>
<pre><code class="language-xml">&lt;!-- 从相册选取照片 --&gt;
&lt;cover-image src='/images/icon/album.png' bindtap='choosePhoto'&gt;&lt;/cover-image&gt;
</code></pre>
</li>
<li>
<p>实现 choosePhoto 函数：</p>
<pre><code class="language-js">  // 从相册选取照片
  choosePhoto() {
    wx.chooseImage({
      count: 1,
      sizeType: ['original'],
      sourceType: ['album'],
      success: (res) =&gt; {
        // console.log(res)
        if (res.tempFilePaths.length &gt; 0) {
          this.setData({
            src: res.tempFilePaths[0],
            isShowPic: true
          }, () =&gt; {
            this.getFaceInfo()
          })
        }
      },
      fail: () =&gt; {
        console.log('选择照片失败！')
        this.setData({
          src: ''
        })
      }
    })
  }
</code></pre>
</li>
</ol>
<h2 id="将选择的照片渲染到屏幕上">将选择的照片渲染到屏幕上</h2>
<ol>
<li>
<p>定义 UI 结构：</p>
<pre><code class="language-xml">&lt;view wx:else&gt;
  &lt;image src='{{src}}' style='width: 100%; height: {{wh}}px; display: block;' mode='aspectFill'&gt;&lt;/image&gt;
&lt;/view&gt;
</code></pre>
</li>
</ol>
<h2 id="重选照片">重选照片</h2>
<ol>
<li>
<p>定义 UI 结构：</p>
<pre><code class="language-xml">&lt;button type='warn' class='reChoose' bindtap='reChoose'&gt;重选照片&lt;/button&gt;
</code></pre>
</li>
<li>
<p>实现 reChoose 函数：</p>
<pre><code class="language-js">// 重新选择照片
  reChoose() {
    this.setData({
      isShowPic: false,
      src: ''
    })
  }
</code></pre>
</li>
</ol>
<h2 id="申请百度ai开放平台账号">申请百度AI开放平台账号</h2>
<ol>
<li>申请百度账号</li>
<li>登录开放平台 <code>http://ai.baidu.com/</code></li>
<li>创建人脸识别的应用</li>
<li>填写应用信息</li>
<li>得到应用的 <code>API Key</code> 和 <code>Secret Key</code></li>
</ol>
<h2 id="实现api鉴权">实现API鉴权</h2>
<pre><code class="language-js">// this.globalData.access_token = 'aaa'
    wx.request({
      method: 'POST',
      url: 'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=自己的ID&amp;client_secret=自己的KEY',
      success: (res) =&gt; {
        this.globalData.access_token = res.data.access_token
      },
      fail: () =&gt; {
        wx.showToast({
          title: '鉴权失败！',
        })
      }
    })
</code></pre>
<h2 id="将图片转码为-base64-字符串">将图片转码为 base64 字符串</h2>
<pre><code class="language-js">const fileManager = wx.getFileSystemManager()
const fileStr = fileManager.readFileSync(this.data.src, 'base64')
</code></pre>
<h2 id="发起请求检测颜值数据">发起请求检测颜值数据</h2>
<pre><code class="language-js">wx.request({
      method: 'POST',
      url: 'https://aip.baidubce.com/rest/2.0/face/v3/detect?access_token=' + token,
      header: {
        'Content-Type': 'application/json'
      },
      data: {
        image_type: 'BASE64',
        image: fileStr,
        // 年龄,颜值分数,表情,性别,是否戴眼镜,情绪
        face_field: 'age,beauty,expression,gender,glasses,emotion'
      },
      success: (res) =&gt; {
        console.log(res)
        if (res.data.result.face_num &lt;= 0) {
          return wx.showToast({
            title: '未检测到人脸！',
          })
        }

        this.setData({
          faceInfo: res.data.result.face_list[0],
          isShowBox: true
        })
      },
      fail: () =&gt; {
        wx.showToast({
          title: '颜值检测失败！',
        })
      },
      complete: () =&gt; {
        wx.hideLoading()
      }
    })
</code></pre>
<h2 id="把英文信息映射为中文信息">把英文信息映射为中文信息</h2>
<ol>
<li>
<p>定义映射关系：</p>
<pre><code class="language-js">data: {
    // 映射关系
    map: {
      gender: { 
          male: '男', female: '女'
      },
      expression: {
        none: '不笑', smile: '微笑', laugh: '大笑'
      },
      glasses: {
        none: '无眼镜',common: '普通眼镜',sun: '墨镜'
      },
      emotion: {
        angry: '愤怒', disgust: '厌恶', fear: '恐惧', happy: '高兴',
        sad: '伤心', surprise: '惊讶', neutral: '无情绪'
      }
    }
}
</code></pre>
</li>
<li>
<p>修改UI结构：</p>
<pre><code class="language-xml">&lt;view class='faceinfo_box' wx:if=&quot;{{isShowBox}}&quot;&gt;
    &lt;view class='face_row'&gt;
      &lt;text&gt;年龄：{{faceInfo.age}}岁&lt;/text&gt;
      &lt;text&gt;性别：{{map.gender[faceInfo.gender.type]}}&lt;/text&gt;
    &lt;/view&gt;
    &lt;view class='face_row'&gt;
      &lt;text&gt;颜值：{{faceInfo.beauty}}分&lt;/text&gt;
      &lt;text&gt;表情：{{map.expression[faceInfo.expression.type]}}&lt;/text&gt;
    &lt;/view&gt;
    &lt;view class='face_row'&gt;
      &lt;text&gt;眼镜：{{map.glasses[faceInfo.glasses.type]}}&lt;/text&gt;
      &lt;text&gt;情绪：{{map.emotion[faceInfo.emotion.type]}}&lt;/text&gt;
    &lt;/view&gt;
&lt;/view&gt;
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[移动端flexible实现rem自适应布局]]></title>
        <id>https://azzsds2008.github.io/post/yi-dong-duan-flexible-shi-xian-rem-zi-gua-ying-bu-ju/</id>
        <link href="https://azzsds2008.github.io/post/yi-dong-duan-flexible-shi-xian-rem-zi-gua-ying-bu-ju/">
        </link>
        <updated>2019-12-24T15:27:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="rem">REM</h1>
<p>rem是一个相对单位<br>
rem的基准是相对于 html 元素的字体大小<br>
比如，根元素html设置font-size=12px, 非根元素设置width:2rem 则换算成px就是24px</p>
<h1 id="flexible">flexible</h1>
<h2 id="原理">原理</h2>
<p>结合CSS3的媒体查询（@media）可以针对不同媒体类型，定义不同的样式</p>
<blockquote>
<p>@media 可以针对不同屏幕尺寸设置不同的样式<br>
改变浏览器大小的过程中，页面会根据浏览器的宽高重新渲染页面<br>
例如（假设设计稿540px 把屏幕划分10等分，实现不同屏幕下，元素等比例缩放）</p>
</blockquote>
<pre><code class="language-javascript">@media screen and (min-width: 320px) {
    html {
        font-size: 32px;
    }
}
@media screen and (min-width: 540px) {
    html {
        font-size: 54px;
    }
}
</code></pre>
<hr>
<h2 id="flexible-2">flexible</h2>
<p>手机淘宝的移动端适配库<br>
它的原理就是把当前设备划分为10等份，在不同设备下，比例是一致的<br>
我们只需要根据设计稿大小设置页面根元素px值</p>
<h2 id="github"><a href="https://github.com/amfe/lib-flexible">github</a></h2>
<hr>
<h2 id="在vue中">在vue中</h2>
<p>一般而言，lib-flexible并不独立出现，而是搭配px2rem-loader一起做适配方案，目的是自动将css中的px转换成rem。以下为它在vue中的使用。</p>
<h3 id="安装-lib-flexible">安装 lib-flexible</h3>
<pre><code>npm install lib-flexible --save-dev
</code></pre>
<h3 id="视口配置">视口配置</h3>
<pre><code class="language-html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=0,minimum-scale=1.0,maximum=scale=1.0&quot;&gt;
</code></pre>
<h3 id="引入-lib-flexible">引入 lib-flexible</h3>
<p>在项目入口文件main.js中引入lib-flexible</p>
<pre><code>import 'lib-flexible'
</code></pre>
<h3 id="安装-px2rem-loader">安装 px2rem-loader</h3>
<pre><code>npm install postcss-px2rem-exclude --save
</code></pre>
<p>在项目根目录文件vue.config.js，如下配置：</p>
<pre><code class="language-js">module.exports = {
  &quot;plugins&quot;: {
    &quot;postcss-import&quot;: {},
    &quot;postcss-url&quot;: {},
    // to edit target browsers: use &quot;browserslist&quot; field in package.json
    &quot;autoprefixer&quot;: {},
    'postcss-px2rem-exclude': {
      remUnit: 75,
      exclude: /node_modules|folder_name/i
    }
  }
</code></pre>
<h2 id="flexible使用注意">flexible使用注意</h2>
<h3 id="关于px2rem的写法">关于px2rem的写法:</h3>
<blockquote>
<p>直接写px，编译后会直接转化成rem ---- 除开下面两种情况，其他长度用这个<br>
在px后面添加/<em>no</em>/，不会转化px，会原样输出。 --- 一般border需用这个<br>
在px后面添加/<em>px</em>/,会根据dpr的不同，生成三套代码。---- 一般字体需用这个</p>
</blockquote>
<h3 id="最大尺寸设置">最大尺寸设置</h3>
<p>flexible的效果会在html 头部设置这样的格式 ：<html data-dpr="1" style="font-size:37.5px;"><head><br>
最大是54px,是因为flexible的js 中的设置<br>
改成750,这样就能 适应750的设计稿了。</p>
<pre><code class="language-javascript"> function refreshRem(){
     var width = docEl.getBoundingClientRect().width;
     if (width / dpr &gt; 750) {	//默认html字体大小（font-size)是54px
         width = 750 * dpr;
     }
     var rem = width / 10;
     docEl.style.fontSize = rem + 'px';
     flexible.rem = win.rem = rem;
 }
</code></pre>
<p>大屏适配可改大，例如我们屏幕尺寸要做以3840 x 2160为设计稿的适配，<br>
要求最小范围是1980，最大为5760，那么我们要修改的则变为：</p>
<pre><code class="language-js">function refreshRem(){
    var width = docEl.getBoundingClientRect().width;
    if (width / dpr &lt; 1980) {
        width = 1980 * dpr;
    } else if (width / dpr &gt; 5760) {
        width = 5760 * dpr;
    }
    var rem = width / 10;
    docEl.style.fontSize = rem + 'px';
    flexible.rem = win.rem = rem;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 解决跨域问题]]></title>
        <id>https://azzsds2008.github.io/post/vue-jie-jue-kua-yu-wen-ti/</id>
        <link href="https://azzsds2008.github.io/post/vue-jie-jue-kua-yu-wen-ti/">
        </link>
        <updated>2019-12-12T04:34:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>刚升级到3.0版本没有2.x版本的webpack目录，查看文档之后发现原来已经移除了，<br>
要配置接口的代理得新建一个叫vue.config.js的配置文件</p>
</blockquote>
<pre><code class="language-javascript">module.exports = {
  devServer: { // 开发环境下runtime
    proxy: { // 代理服务器
	  // 接口地址为 http://127.0.0.1:7001/api/register
      '/api/register': { 
        target: 'http://127.0.0.1:7001',
        secure: false, //是否使用 Https安全传输协议
        changeOrigin: true 
      }
    }
  }
}
</code></pre>
<h2 id="什么是同源策略">什么是同源策略</h2>
<blockquote>
<p>同源策略/SOP（Same origin policy）是一种浏览器约定，它是浏览器最核心也最基本的安全功能，&gt; 为了防止浏览器受到XSS、CSFR的攻击，浏览器采用了同源策略（保护Cookie）规定某域下的客户端在&gt; 没明确授权的情况下不能读写另一个域的资源，只有当&quot;协议+域名+端口&quot;三者相同都相同时才为同源。</p>
</blockquote>
<h2 id="什么是跨域">什么是跨域</h2>
<blockquote>
<p>顾名思义就是一个网域向另一个网域进行资源交互，即两个网域的&quot;协议+域名+端口&quot;不同。跨域访问违反&gt; 了同源策略，所以当请求不在同一域名下的资源文件（“协议+域名+端口“）时就报了<br>
No &gt;'Access-Control-Allow-Origin'错误。</p>
</blockquote>
<h1 id="正确的跨域代理配置">正确的跨域代理配置</h1>
<h2 id="单服务器请求配置">单服务器请求配置</h2>
<p>比如说我们要通过http://192.168.31.180:8080/login访问后台接口 http://192.168.31.180:8000/login实现登录功能。设置代理之后代理会检查请求开头是否与代理映射相符，不符合则不走代理，所以使用axios请求的时候无需配置axios.defaults.baseURL属性（否则会跳过代理）。当匹配到映射路径时就会进入代理并将 target属性补全到请求路径。这种方式虽然成功了，但是还是存在之前遇到的缺陷，因为匹配的是‘/’，Vue的路由也符合这一条件，所以刷新后会进入代理配置直接跳转到后台路由了。<br>
<img src="https://azzsds2008.github.io/post-images/1587013070021.jpg" alt="" loading="lazy"></p>
<h2 id="多服务器请求配置">多服务器请求配置</h2>
<p>当我们遇到要访问多个后台接口时，我们可以为每个服务器配置不同代理服务，以映射路径作为区分当我们访问到相应的路径时走对应的代理服务器，但真实的请求中没有该路径，所以我们需要利用pathRewrite属性把该路径去掉。所以为了避免路由直接跳转至后台，一个服务器接口也这种配置，只有在请求接口的时候才走代理。<br>
<img src="https://azzsds2008.github.io/post-images/1587013066004.jpg" alt="" loading="lazy"><br>
1，路由请求中添加一个路由标识，如：/api/login（切勿设置axios.defaults.baseURL属性）</p>
<p>2，代理中映射路径指向标识路由，当匹配到映射路径时就会进入代理并 target属性补全到请求路径。</p>
<p>3，利用pathRewrite属性重写路径，还原真实的请求路由。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VueX]]></title>
        <id>https://azzsds2008.github.io/post/vuex/</id>
        <link href="https://azzsds2008.github.io/post/vuex/">
        </link>
        <updated>2019-12-05T14:06:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1vuex概述">1.Vuex概述</h3>
<p>Vuex是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间的数据共享<br>
<a href="https://vuex.vuejs.org/zh/api/">vuex官方文档</a></p>
<blockquote>
<p>使用Vuex管理数据的好处：<br>
-A.能够在vuex中集中管理共享的数据，便于开发和后期进行维护<br>
-B.能够高效的实现组件之间的数据共享，提高开发效率<br>
-C.存储在vuex中的数据是响应式的，当数据发生改变时，页面中的数据也会同步更新</p>
</blockquote>
<hr>
<h3 id="2vuex的基本使用">2.Vuex的基本使用</h3>
<p>创建带有vuex的vue项目，打开终端，输入命令：vue ui<br>
当项目仪表盘打开之后，我们点击页面左上角的项目管理下拉列表，再点击Vue项目管理器<br>
点击创建项目，如下图所示</p>
<h4 id="第一步设置项目名称和包管理器">第一步，设置项目名称和包管理器</h4>
<figure data-type="image" tabindex="1"><img src="https://azzsds2008.github.io/post-images/1586873298629.png" alt="" loading="lazy"></figure>
<h4 id="第二步设置手动配置项目">第二步，设置手动配置项目</h4>
<figure data-type="image" tabindex="2"><img src="https://azzsds2008.github.io/post-images/1586873309281.png" alt="" loading="lazy"></figure>
<h4 id="第三步设置功能项">第三步，设置功能项</h4>
<p><img src="https://azzsds2008.github.io/post-images/1586873314945.png" alt="" loading="lazy"><br>
<img src="https://azzsds2008.github.io/post-images/1586873318994.png" alt="" loading="lazy"></p>
<h4 id="第四步创建项目">第四步，创建项目</h4>
<h2 id=""><img src="https://azzsds2008.github.io/post-images/1586873323073.png" alt="" loading="lazy"></h2>
<h3 id="3使用vuex完成计数器案例">3.使用Vuex完成计数器案例</h3>
<p>打开刚刚创建的vuex项目，找到src目录中的App.vue组件，将代码重新编写如下：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;my-addition&gt;&lt;/my-addition&gt;
    &lt;p&gt;----------------------------------------&lt;/p&gt;
    &lt;my-subtraction&gt;&lt;/my-subtraction&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import Addition from './components/Addition.vue'
import Subtraction from './components/Subtraction.vue'
export default {
  data() {
    return {}
  },
  components: {
    'my-subtraction': Subtraction,
    'my-addition': Addition
  }
}
&lt;/script&gt;
&lt;style&gt;
&lt;/style&gt;
</code></pre>
<hr>
<p>在components文件夹中创建Addition.vue组件，代码如下：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;div&gt;
        &lt;h3&gt;当前最新的count值为：&lt;/h3&gt;
        &lt;button&gt;+1&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {}
  }
}
&lt;/script&gt;
&lt;style&gt;
&lt;/style&gt;
</code></pre>
<p>在components文件夹中创建Subtraction.vue组件，代码如下：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;div&gt;
        &lt;h3&gt;当前最新的count值为：&lt;/h3&gt;
        &lt;button&gt;-1&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {}
  }
}
&lt;/script&gt;
&lt;style&gt;
&lt;/style&gt;
</code></pre>
<p>最后在项目根目录(与src平级)中创建 .prettierrc 文件，编写代码如下：</p>
<pre><code class="language-javascript">{
    &quot;semi&quot;:false,
    &quot;singleQuote&quot;:true
}
</code></pre>
<hr>
<h3 id="4vuex中的核心特性">4.Vuex中的核心特性</h3>
<h4 id="astate">A.State</h4>
<pre><code>State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储
例如，打开项目中的store.js文件，在State对象中可以添加我们要共享的数据，如：count:0

在组件中访问State的方式：
1).this.$store.state.全局数据名称  如：this.$store.state.count
2).先按需导入mapState函数： import { mapState } from 'vuex'
然后数据映射为计算属性： computed:{ ...mapState(['全局数据名称']) }
</code></pre>
<h4 id="bmutation">B.Mutation</h4>
<p>Mutation用于修改变更$store中的数据<br>
使用方式：<br>
打开store.js文件，在mutations中添加代码如下</p>
<pre><code class="language-javascript">mutations: {
    add(state,step){
      //第一个形参永远都是state也就是$state对象
      //第二个形参是调用add时传递的参数
      state.count+=step;
    }
  }
</code></pre>
<hr>
<p>然后在Addition.vue中给按钮添加事件代码如下：</p>
<pre><code class="language-javascript">&lt;button @click=&quot;Add&quot;&gt;+1&lt;/button&gt;

methods:{
  Add(){
    //使用commit函数调用mutations中的对应函数，
    //第一个参数就是我们要调用的mutations中的函数名
    //第二个参数就是传递给add函数的参数
    this.$store.commit('add',10)
  }
}
</code></pre>
<p>使用mutations的第二种方式：<br>
import { mapMutations } from 'vuex'</p>
<p>methods:{<br>
...mapMutations(['add'])<br>
}<br>
如下：</p>
<pre><code class="language-javascript">import { mapState,mapMutations } from 'vuex'

export default {
  data() {
    return {}
  },
  methods:{
      //获得mapMutations映射的sub函数
      ...mapMutations(['sub']),
      //当点击按钮时触发Sub函数
      Sub(){
          //调用sub函数完成对数据的操作
          this.sub(10);
      }
  },
  computed:{
      ...mapState(['count'])
      
  }
}
</code></pre>
<h4 id="caction">C.Action</h4>
<p>在mutations中不能编写异步的代码，会导致vue调试器的显示出错。<br>
在vuex中我们可以使用Action来执行异步操作。<br>
操作步骤如下：<br>
打开store.js文件，修改Action，如下：</p>
<pre><code class="language-javascript">actions: {
  addAsync(context,step){
    setTimeout(()=&gt;{
      context.commit('add',step);
    },2000)
  }
}
</code></pre>
<p>然后在Addition.vue中给按钮添加事件代码如下：</p>
<pre><code class="language-javascript">&lt;button @click=&quot;AddAsync&quot;&gt;...+1&lt;/button&gt;

methods:{
  AddAsync(){
    this.$store.dispatch('addAsync',5)
  }
}
</code></pre>
<hr>
<p>第二种方式：<br>
import { mapActions } from 'vuex'</p>
<p>methods:{<br>
...mapMutations(['subAsync'])<br>
}<br>
如下：</p>
<pre><code class="language-javascript">import { mapState,mapMutations,mapActions } from 'vuex'

export default {
  data() {
    return {}
  },
  methods:{
      //获得mapMutations映射的sub函数
      ...mapMutations(['sub']),
      //当点击按钮时触发Sub函数
      Sub(){
          //调用sub函数完成对数据的操作
          this.sub(10);
      },
      //获得mapActions映射的addAsync函数
      ...mapActions(['subAsync']),
      asyncSub(){
          this.subAsync(5);
      }
  },
  computed:{
      ...mapState(['count'])
      
  }
}
</code></pre>
<h4 id="dgetter">D.Getter</h4>
<p>Getter用于对Store中的数据进行加工处理形成新的数据<br>
它只会包装Store中保存的数据，并不会修改Store中保存的数据，当Store中的数据发生变化时，Getter生成的内容也会随之变化<br>
打开store.js文件，添加getters，如下：</p>
<pre><code class="language-javascript">export default new Vuex.Store({
  .......
  getters:{
    //添加了一个showNum的属性
    showNum : state =&gt;{
      return '最新的count值为：'+state.count;
    }
  }
})
</code></pre>
<p>然后打开Addition.vue中，添加插值表达式使用getters</p>
<pre><code class="language-html">&lt;h3&gt;{{$store.getters.showNum}}&lt;/h3&gt;
</code></pre>
<p>或者也可以在Addition.vue中，导入mapGetters，并将之映射为计算属性</p>
<pre><code class="language-javascript">import { mapGetters } from 'vuex'
computed:{
  ...mapGetters(['showNum'])
}
</code></pre>
<hr>
<h3 id="5vuex案例">5.vuex案例</h3>
<h4 id="a初始化案例">A.初始化案例</h4>
<p>首先使用vue ui初始化一个使用vuex的案例<br>
然后打开public文件夹，创建一个list.json文件，文件代码如下：</p>
<pre><code class="language-javascript">[
    {
        &quot;id&quot;: 0,
        &quot;info&quot;: &quot;Racing car sprays burning fuel into crowd.&quot;,
        &quot;done&quot;: false
    },
    {
        &quot;id&quot;: 1,
        &quot;info&quot;: &quot;Japanese princess to wed commoner.&quot;,
        &quot;done&quot;: false
    },
    {
        &quot;id&quot;: 2,
        &quot;info&quot;: &quot;Australian walks 100km after outback crash.&quot;,
        &quot;done&quot;: false
    },
    {
        &quot;id&quot;: 3,
        &quot;info&quot;: &quot;Man charged over missing wedding girl.&quot;,
        &quot;done&quot;: false
    },
    {
        &quot;id&quot;: 4,
        &quot;info&quot;: &quot;Los Angeles battles huge wildfires.&quot;,
        &quot;done&quot;: false
    }
]
</code></pre>
<p>再接着，打开main.js,添加store.js的引入，如下：</p>
<pre><code class="language-javascript">import Vue from 'vue'
import App from './App.vue'
import store from './store.js'

// 1. 导入 ant-design-vue 组件库
import Antd from 'ant-design-vue'
// 2. 导入组件库的样式表
import 'ant-design-vue/dist/antd.css'

Vue.config.productionTip = false
// 3. 安装组件库
Vue.use(Antd)

new Vue({
  store,
  render: h =&gt; h(App)
}).$mount('#app')
</code></pre>
<p>再接着打开store.js，添加axios请求json文件获取数据的代码，如下：</p>
<pre><code class="language-javascript">import Vue from 'vue'
import Vuex from 'vuex'
import axios from 'axios'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    //所有任务列表
    list: [],
    //文本输入框中的值
    inputValue: 'AAA'
  },
  mutations: {
    initList(state, list) {
      state.list = list
    },
    setInputValue(state,value){
      state.inputValue = value
    }
  },
  actions: {
    getList(context) {
      axios.get('/list.json').then(({ data }) =&gt; {
        console.log(data);
        context.commit('initList', data)
      })
    }
  }
})
</code></pre>
<p>最后，代开App.vue文件，将store中的数据获取并展示：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;a-input placeholder=&quot;请输入任务&quot; class=&quot;my_ipt&quot; :value=&quot;inputValue&quot; @change=&quot;handleInputChange&quot; /&gt;
    &lt;a-button type=&quot;primary&quot;&gt;添加事项&lt;/a-button&gt;

    &lt;a-list bordered :dataSource=&quot;list&quot; class=&quot;dt_list&quot;&gt;
      &lt;a-list-item slot=&quot;renderItem&quot; slot-scope=&quot;item&quot;&gt;
        &lt;!-- 复选框 --&gt;
        &lt;a-checkbox :checked=&quot;item.done&quot;&gt;{{item.info}}&lt;/a-checkbox&gt;
        &lt;!-- 删除链接 --&gt;
        &lt;a slot=&quot;actions&quot;&gt;删除&lt;/a&gt;
      &lt;/a-list-item&gt;

      &lt;!-- footer区域 --&gt;
      &lt;div slot=&quot;footer&quot; class=&quot;footer&quot;&gt;
        &lt;!-- 未完成的任务个数 --&gt;
        &lt;span&gt;0条剩余&lt;/span&gt;
        &lt;!-- 操作按钮 --&gt;
        &lt;a-button-group&gt;
          &lt;a-button type=&quot;primary&quot;&gt;全部&lt;/a-button&gt;
          &lt;a-button&gt;未完成&lt;/a-button&gt;
          &lt;a-button&gt;已完成&lt;/a-button&gt;
        &lt;/a-button-group&gt;
        &lt;!-- 把已经完成的任务清空 --&gt;
        &lt;a&gt;清除已完成&lt;/a&gt;
      &lt;/div&gt;
    &lt;/a-list&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { mapState } from 'vuex'

export default {
  name: 'app',
  data() {
    return {
      // list:[]
    }
  },
  created(){
    // console.log(this.$store);
    this.$store.dispatch('getList')
  },
  methods:{
    handleInputChange(e){
      // console.log(e.target.value)
      this.$store.commit('setInputValue',e.target.value)
    }
  },
  computed:{
    ...mapState(['list','inputValue'])
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
#app {
  padding: 10px;
}

.my_ipt {
  width: 500px;
  margin-right: 10px;
}

.dt_list {
  width: 500px;
  margin-top: 10px;
}

.footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
&lt;/style&gt;
</code></pre>
<h4 id="b完成添加事项">B.完成添加事项</h4>
<p>首先，打开App.vue文件，给“添加事项”按钮绑定点击事件，编写处理函数</p>
<pre><code class="language-javascript">//绑定事件
&lt;a-button type=&quot;primary&quot; @click=&quot;addItemToList&quot;&gt;添加事项&lt;/a-button&gt;

//编写事件处理函数
methods:{
    ......
    addItemToList(){
      //向列表中新增事项
      if(this.inputValue.trim().length &lt;= 0){
        return this.$message.warning('文本框内容不能为空')
      }

      this.$store.commit('addItem')
    }
  }
</code></pre>
<p>然后打开store.js编写addItem</p>
<pre><code class="language-javascript">export default new Vuex.Store({
  state: {
    //所有任务列表
    list: [],
    //文本输入框中的值
    inputValue: 'AAA',
    //下一个id
    nextId:5
  },
  mutations: {
    ........
    //添加列表项
    addItem(state){
      const obj = {
        id :state.nextId,
        info: state.inputValue.trim(),
        done:false
      }
      //将创建好的事项添加到数组list中
      state.list.push(obj)
      //将nextId值自增
      state.nextId++
      state.inputValue = ''
    }
  }
  ......
})

</code></pre>
<h4 id="c完成删除事项">C.完成删除事项</h4>
<p>首先，打开App.vue文件，给“删除”按钮绑定点击事件，编写处理函数</p>
<pre><code class="language-javascript">//绑定事件
&lt;a slot=&quot;actions&quot; @click=&quot;removeItemById(item.id)&quot;&gt;删除&lt;/a&gt;

//编写事件处理函数
methods:{
    ......
    removeItemById(id){
      //根据id删除事项
      this.$store.commit('removeItem',id)
    }
  }
</code></pre>
<p>然后打开store.js编写addItem</p>
<pre><code class="language-javascript">export default new Vuex.Store({
  ......
  mutations: {
    ........
    removeItem(state,id){
      //根据id删除事项数据
      const index = state.list.findIndex( x =&gt; x.id === id )
      // console.log(index);
      if(index != -1) state.list.splice(index,1);
    }
  }
  ......
})
</code></pre>
<hr>
<h4 id="d完成选中状态的改变">D.完成选中状态的改变</h4>
<p>首先，打开App.vue文件，给“复选”按钮绑定点击事件，编写处理函数</p>
<pre><code class="language-javascript">//绑定事件
&lt;a-checkbox :checked=&quot;item.done&quot; @change=&quot;cbStateChanged(item.id,$event)&quot;&gt;{{item.info}}&lt;/a-checkbox&gt;

//编写事件处理函数
methods:{
    ......
    cbStateChanged(id,e){
      //复选框状态改变时触发
      const param = {
        id:id,
        status:e.target.checked
      }

      //根据id更改事项状态
      this.$store.commit('changeStatus',param)
    }
  }
</code></pre>
<hr>
<p>然后打开store.js编写addItem</p>
<pre><code class="language-javascript">export default new Vuex.Store({
  ......
  mutations: {
    ........
    changeStatus(state,param){
      //根据id改变对应事项的状态
      const index = state.list.findIndex( x =&gt; x.id === param.id )
      if(index != -1) state.list[index].done = param.status
    }
  }
  ......
})
</code></pre>
<h4 id="e剩余项统计">E.剩余项统计</h4>
<p>打开store.js，添加getters完成剩余项统计</p>
<pre><code class="language-javascript">getters:{
  unDoneLength(state){
    const temp = state.list.filter( x =&gt; x.done === false )
    console.log(temp)
    return temp.length
  }
}
</code></pre>
<hr>
<p>打开App.vue，使用getters展示剩余项</p>
<pre><code class="language-javascript">//使用映射好的计算属性展示剩余项
&lt;!-- 未完成的任务个数 --&gt;
&lt;span&gt;{{unDoneLength}}条剩余&lt;/span&gt;

//导入getters
import { mapState,mapGetters } from 'vuex'
//映射
computed:{
  ...mapState(['list','inputValue']),
  ...mapGetters(['unDoneLength'])
}
</code></pre>
<hr>
<h4 id="f清除完成事项">F.清除完成事项</h4>
<p>首先，打开App.vue文件，给“清除已完成”按钮绑定点击事件，编写处理函数</p>
<pre><code class="language-javascript">&lt;!-- 把已经完成的任务清空 --&gt;
&lt;a @click=&quot;clean&quot;&gt;清除已完成&lt;/a&gt;

//编写事件处理函数
methods:{
  ......
  clean(){
    //清除已经完成的事项
    this.$store.commit('cleanDone')
  }
}
</code></pre>
<hr>
<p>然后打开store.js编写addItem</p>
<pre><code class="language-javascript">export default new Vuex.Store({
  ......
  mutations: {
    ........
    cleanDone(state){
      state.list = state.list.filter( x =&gt; x.done === false )
    }
  }
  ......
})
</code></pre>
<hr>
<h4 id="g点击选项卡切换事项">G.点击选项卡切换事项</h4>
<p>打开App.vue，给“全部”，“未完成”，“已完成”三个选项卡绑定点击事件，编写处理函数<br>
并将列表数据来源更改为一个getters。</p>
<pre><code class="language-html">&lt;a-list bordered :dataSource=&quot;infoList&quot; class=&quot;dt_list&quot;&gt;
  ......
  &lt;!-- 操作按钮 --&gt;
  &lt;a-button-group&gt;
    &lt;a-button :type=&quot;viewKey ==='all'?'primary':'default'&quot; @click=&quot;changeList('all')&quot;&gt;全部&lt;/a-button&gt;
    &lt;a-button :type=&quot;viewKey ==='undone'?'primary':'default'&quot; @click=&quot;changeList('undone')&quot;&gt;未完成&lt;/a-button&gt;
    &lt;a-button :type=&quot;viewKey ==='done'?'primary':'default'&quot; @click=&quot;changeList('done')&quot;&gt;已完成&lt;/a-button&gt;
  &lt;/a-button-group&gt;
  ......
&lt;/a-list&gt;

//编写事件处理函数以及映射计算属性
methods:{
  ......
  changeList( key ){
    //点击“全部”，“已完成”，“未完成”时触发
    this.$store.commit('changeKey',key)
  }
},
computed:{
  ...mapState(['list','inputValue','viewKey']),
  ...mapGetters(['unDoneLength','infoList'])
}
</code></pre>
<hr>
<p>打开store.js，添加getters，mutations，state</p>
<pre><code class="language-javascript">export default new Vuex.Store({
  state: {
    ......
    //保存默认的选项卡值
    viewKey:'all'
  },
  mutations: {
    ......
    changeKey(state,key){
      //当用户点击“全部”，“已完成”，“未完成”选项卡时触发
      state.viewKey = key
    }
  },
  ......
  getters:{
    .......
    infoList(state){
      if(state.viewKey === 'all'){
        return state.list
      }
      if(state.viewKey === 'undone'){
        return state.list.filter( x =&gt; x.done === false )
      }
      if(state.viewKey === 'done'){
        return state.list.filter( x =&gt; x.done === true )
      }
    }
  }
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue项目优化(二)]]></title>
        <id>https://azzsds2008.github.io/post/vue-xiang-mu-you-hua-er/</id>
        <link href="https://azzsds2008.github.io/post/vue-xiang-mu-you-hua-er/">
        </link>
        <updated>2019-12-02T13:55:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定制首页内容">定制首页内容</h2>
<p>开发环境的首页和发布环境的首页展示内容的形式有所不同<br>
如开发环境中使用的是import加载第三方包，而发布环境则是使用CDN，那么首页也需根据环境不同来进行不同的实现<br>
我们可以通过插件的方式来定制首页内容，打开vue.config.js，编写代码如下：</p>
<pre><code class="language-javascript">module.exports = {
    chainWebpack:config=&gt;{
        config.when(process.env.NODE_ENV === 'production',config=&gt;{
            ......
            
            //使用插件
            config.plugin('html').tap(args=&gt;{
                //添加参数isProd
                args[0].isProd = true
                return args
            })
        })

        config.when(process.env.NODE_ENV === 'development',config=&gt;{
            config.entry('app').clear().add('./src/main-dev.js')

            //使用插件
            config.plugin('html').tap(args=&gt;{
                //添加参数isProd
                args[0].isProd = false
                return args
            })
        })
    }
}
</code></pre>
<p>然后在public/index.html中使用插件判断是否为发布环境并定制首页内容</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
    &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;
    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.isProd ? '' : 'dev - ' %&gt;电商后台管理系统&lt;/title&gt;

    &lt;% if(htmlWebpackPlugin.options.isProd){ %&gt;
    &lt;!-- nprogress 的样式表文件 --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css&quot; /&gt;
    ........
    &lt;!-- element-ui 的 js 文件 --&gt;
    &lt;script src=&quot;https://cdn.staticfile.org/element-ui/2.8.2/index.js&quot;&gt;&lt;/script&gt;
    &lt;% } %&gt;
  &lt;/head&gt;
  .......
</code></pre>
<hr>
<h2 id="路由懒加载">路由懒加载</h2>
<p>当路由被访问时才加载对应的路由文件，就是路由懒加载。<br>
路由懒加载实现步骤：<br>
1.安装 @babel/plugin-syntax-dynamic-import<br>
打开vue控制台，点击依赖-&gt;安装依赖-&gt;开发依赖-&gt;搜索@babel/plugin-syntax-dynamic-import<br>
点击安装。</p>
<h3 id="在babelconfigjs中声明该插件打开babelconfigjs">在babel.config.js中声明该插件，打开babel.config.js</h3>
<pre><code class="language-javascript">//项目发布阶段需要用到的babel插件
const productPlugins = []

//判断是开发还是发布阶段
if(process.env.NODE_ENV === 'production'){
  //发布阶段
  productPlugins.push(&quot;transform-remove-console&quot;)
}

module.exports = {
  &quot;presets&quot;: [
    &quot;@vue/app&quot;
  ],
  &quot;plugins&quot;: [
    [
      &quot;component&quot;,
      {
        &quot;libraryName&quot;: &quot;element-ui&quot;,
        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;
      }
    ],
    ...productPlugins,
    //配置路由懒加载插件
    &quot;@babel/plugin-syntax-dynamic-import&quot;
  ]
}
</code></pre>
<hr>
<h3 id="将路由更改为按需加载的形式打开routerjs更改引入组件代码如下">将路由更改为按需加载的形式，打开router.js，更改引入组件代码如下：</h3>
<pre><code class="language-javascript">import Vue from 'vue'
import Router from 'vue-router'
const Login = () =&gt; import(/* webpackChunkName:&quot;login_home_welcome&quot; */ './components/Login.vue')
// import Login from './components/Login.vue'
const Home = () =&gt; import(/* webpackChunkName:&quot;login_home_welcome&quot; */ './components/Home.vue')
// import Home from './components/Home.vue'
const Welcome = () =&gt; import(/* webpackChunkName:&quot;login_home_welcome&quot; */ './components/Welcome.vue')
// import Welcome from './components/Welcome.vue'
const Users = () =&gt; import(/* webpackChunkName:&quot;user&quot; */ './components/user/Users.vue')
// import Users from './components/user/Users.vue'
const Rights = () =&gt; import(/* webpackChunkName:&quot;power&quot; */ './components/power/Rights.vue')
// import Rights from './components/power/Rights.vue'
const Roles = () =&gt; import(/* webpackChunkName:&quot;power&quot; */ './components/power/Roles.vue')
// import Roles from './components/power/Roles.vue'
const Cate = () =&gt; import(/* webpackChunkName:&quot;goods&quot; */ './components/goods/Cate.vue')
// import Cate from './components/goods/Cate.vue'
const Params = () =&gt; import(/* webpackChunkName:&quot;goods&quot; */ './components/goods/Params.vue')
// import Params from './components/goods/Params.vue'
const GoodList = () =&gt; import(/* webpackChunkName:&quot;goods&quot; */ './components/goods/List.vue')
// import GoodList from './components/goods/List.vue'
const GoodAdd = () =&gt; import(/* webpackChunkName:&quot;goods&quot; */ './components/goods/Add.vue')
// import GoodAdd from './components/goods/Add.vue'
const Order = () =&gt; import(/* webpackChunkName:&quot;order&quot; */ './components/order/Order.vue')
// import Order from './components/order/Order.vue'
const Report = () =&gt; import(/* webpackChunkName:&quot;report&quot; */ './components/report/Report.vue')
// import Report from './components/report/Report.vue'
</code></pre>
<h2 id="项目上线">项目上线</h2>
<h3 id="通过node创建服务器">通过node创建服务器</h3>
<p>在vue_shop同级创建一个文件夹vue_shop_server存放node服务器<br>
使用终端打开vue_shop_server文件夹，输入命令 npm init -y<br>
初始化包之后，输入命令 npm i express -S<br>
打开vue_shop目录，复制dist文件夹，粘贴到vue_shop_server中<br>
在vue_shop_server文件夹中创建app.js文件,编写代码如下：</p>
<pre><code class="language-javascript">const express = require('express')

const app = express()

app.use(express.static('./dist'))

app.listen(8998,()=&gt;{
    console.log(&quot;server running at http://127.0.0.1:8998&quot;)
})
</code></pre>
<p>然后再次在终端中输入  node app.js</p>
<h3 id="开启gzip压缩">开启gzip压缩</h3>
<p>打开vue_shop_server文件夹的终端，输入命令：npm i compression -D<br>
打开app.js,编写代码：</p>
<pre><code class="language-javascript">const express = require('express')

const compression = require('compression')

const app = express()

app.use(compression())
app.use(express.static('./dist'))

app.listen(8998,()=&gt;{
    console.log(&quot;server running at http://127.0.0.1:8998&quot;)
})
</code></pre>
<h3 id="配置https服务">配置https服务</h3>
<p>配置https服务一般是后台进行处理，前端开发人员了解即可。<br>
首先，需要申请SSL证书，进入https://freessl.cn官网<br>
在后台导入证书，打开今天资料/素材，复制素材中的两个文件到vue_shop_server中<br>
打开app.js文件，编写代码导入证书，并开启https服务</p>
<pre><code class="language-javascript">const express = require('express')
const compression = require('compression')
const https = require('https')
const fs = require('fs')

const app = express()
//创建配置对象设置公钥和私钥
const options = {
    cert:fs.readFileSync('./full_chain.pem'),
    key:fs.readFileSync('./private.key')
}

app.use(compression())
app.use(express.static('./dist'))

// app.listen(8998,()=&gt;{
//     console.log(&quot;server running at http://127.0.0.1:8998&quot;)
// })

//启动https服务
https.createServer(options,app).listen(443)
</code></pre>
<blockquote>
<p>注意：因为我们使用的证书有问题，所以无法正常使用https服务</p>
</blockquote>
<hr>
<h2 id="使用pm2管理应用">使用pm2管理应用</h2>
<p>打开vue_shop_server文件夹的终端，输入命令：npm i pm2 -g<br>
使用pm2启动项目，在终端中输入命令：pm2 start app.js --name 自定义名称<br>
查看项目列表命令：pm2 ls<br>
重启项目：pm2 restart 自定义名称<br>
停止项目：pm2 stop 自定义名称<br>
删除项目：pm2 delete 自定义名称</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue项目优化(一)]]></title>
        <id>https://azzsds2008.github.io/post/vue-xiang-mu-you-hua/</id>
        <link href="https://azzsds2008.github.io/post/vue-xiang-mu-you-hua/">
        </link>
        <updated>2019-12-01T12:36:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="项目优化实现步骤">项目优化实现步骤：</h1>
<ul>
<li>生成打包报告，根据报告优化项目</li>
<li>第三方库启用CDN</li>
<li>Element-UI组件按需加载</li>
<li>路由懒加载</li>
<li>
<h2 id="首页内容定制">首页内容定制</h2>
</li>
</ul>
<h2 id="添加进度条">添加进度条</h2>
<p>给项目添加进度条效果，先打开项目控制台，打开依赖，安装<strong>nprogress</strong><br>
打开main.js，编写如下代码</p>
<pre><code class="language-javascript">//导入进度条插件
import NProgress from 'nprogress'
//导入进度条样式
import 'nprogress/nprogress.css'
.....
//请求在到达服务器之前，先会调用use中的这个回调函数来添加请求头信息
axios.interceptors.request.use(config =&gt; {
  //当进入request拦截器，表示发送了请求，我们就开启进度条
  NProgress.start()
  //为请求头对象，添加token验证的Authorization字段
  config.headers.Authorization = window.sessionStorage.getItem(&quot;token&quot;)
  //必须返回config
  return config
})
//在response拦截器中，隐藏进度条
axios.interceptors.response.use(config =&gt;{
  //当进入response拦截器，表示请求已经结束，我们就结束进度条
  NProgress.done()
  return config
})
</code></pre>
<hr>
<h2 id="build阶段移除所有的console">build阶段移除所有的console</h2>
<p>安装一个插件（babel-plugin-transform-remove-console）在项目build阶段移除所有的console信息<br>
打开项目控制台，点击依赖-&gt;开发依赖，输入babel-plugin-transform-remove-console，安装<br>
打开babel.config.js，编辑代码如下：</p>
<pre><code class="language-javascript">//项目发布阶段需要用到的babel插件
const productPlugins = []

//判断是开发还是发布阶段
if(process.env.NODE_ENV === 'production'){
  //发布阶段
  productPlugins.push(&quot;transform-remove-console&quot;)
}

module.exports = {
  &quot;presets&quot;: [
    &quot;@vue/app&quot;
  ],
  &quot;plugins&quot;: [
    [
      &quot;component&quot;,
      {
        &quot;libraryName&quot;: &quot;element-ui&quot;,
        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;
      }
    ],
    ...productPlugins
  ]
}
</code></pre>
<hr>
<h2 id="生成打包报告">生成打包报告</h2>
<ul>
<li>命令行形式生成打包报告<br>
vue-cli-service build --report</li>
<li>在vue控制台生成打包报告<br>
点击“任务”=&gt;“build”=&gt;“运行”<br>
运行完毕之后点击右侧“分析”，“控制台”面板查看报告<br>
<img src="https://azzsds2008.github.io/post-images/1586871118025.png" alt="" loading="lazy"></li>
</ul>
<hr>
<h2 id="修改webpack的默认配置">修改webpack的默认配置</h2>
<p>默认情况下，vue-cli 3.0生成的项目，隐藏了webpack配置项，如果我们需要配置webpack<br>
需要通过vue.config.js来配置。<br>
在项目根目录中创建vue.config.js文件，</p>
<pre><code class="language-javascript">module.exports = {
    chainWebpack:config=&gt;{
        //发布模式
        config.when(process.env.NODE_ENV === 'production',config=&gt;{
            //entry找到默认的打包入口，调用clear则是删除默认的打包入口
            //add添加新的打包入口
            config.entry('app').clear().add('./src/main-prod.js')
        })
        //开发模式
        config.when(process.env.NODE_ENV === 'development',config=&gt;{
            config.entry('app').clear().add('./src/main-dev.js')
        })
    }
}
</code></pre>
<blockquote>
<p>补充：<br>
chainWebpack可以通过链式编程的形式，修改webpack配置<br>
configureWebpack可以通过操作对象的形式，修改webpack配置</p>
</blockquote>
<hr>
<h2 id="加载外部cdn">加载外部CDN</h2>
<p>默认情况下，依赖项的所有第三方包都会被打包到js/chunk-vendors.******.js文件中，导致该js文件过大<br>
那么我们可以通过externals排除这些包，使它们不被打包到js/chunk-vendors.******.js文件中</p>
<pre><code class="language-javascript">module.exports = {
    chainWebpack:config=&gt;{
        //发布模式
        config.when(process.env.NODE_ENV === 'production',config=&gt;{
            //entry找到默认的打包入口，调用clear则是删除默认的打包入口
            //add添加新的打包入口
            config.entry('app').clear().add('./src/main-prod.js')

            //使用externals设置排除项
            config.set('externals',{
                vue:'Vue',
                'vue-router':'VueRouter',
                axios:'axios',
                lodash:'_',
                echarts:'echarts',
                nprogress:'NProgress',
                'vue-quill-editor':'VueQuillEditor'
            })
        })
        //开发模式
        config.when(process.env.NODE_ENV === 'development',config=&gt;{
            config.entry('app').clear().add('./src/main-dev.js')
        })
    }
}
</code></pre>
<hr>
<p>设置好排除之后，为了使我们可以使用vue，axios等内容，我们需要加载外部CDN的形式解决引入依赖项。<br>
打开开发入口文件main-prod.js,删除掉默认的引入代码</p>
<pre><code class="language-javascript">import Vue from 'vue'
import App from './App.vue'
import router from './router'
// import './plugins/element.js'
//导入字体图标
import './assets/fonts/iconfont.css'
//导入全局样式
import './assets/css/global.css'
//导入第三方组件vue-table-with-tree-grid
import TreeTable from 'vue-table-with-tree-grid'
//导入进度条插件
import NProgress from 'nprogress'
//导入进度条样式
// import 'nprogress/nprogress.css'
// //导入axios
import axios from 'axios'
// //导入vue-quill-editor（富文本编辑器）
import VueQuillEditor from 'vue-quill-editor'
// //导入vue-quill-editor的样式
// import 'quill/dist/quill.core.css'
// import 'quill/dist/quill.snow.css'
// import 'quill/dist/quill.bubble.css'

axios.defaults.baseURL = 'http://127.0.0.1:8888/api/private/v1/'
//请求在到达服务器之前，先会调用use中的这个回调函数来添加请求头信息
axios.interceptors.request.use(config =&gt; {
  //当进入request拦截器，表示发送了请求，我们就开启进度条
  NProgress.start()
  //为请求头对象，添加token验证的Authorization字段
  config.headers.Authorization = window.sessionStorage.getItem(&quot;token&quot;)
  //必须返回config
  return config
})
//在response拦截器中，隐藏进度条
axios.interceptors.response.use(config =&gt;{
  //当进入response拦截器，表示请求已经结束，我们就结束进度条
  NProgress.done()
  return config
})
Vue.prototype.$http = axios

Vue.config.productionTip = false

//全局注册组件
Vue.component('tree-table', TreeTable)
//全局注册富文本组件
Vue.use(VueQuillEditor)

//创建过滤器将秒数过滤为年月日，时分秒
Vue.filter('dateFormat',function(originVal){
  const dt = new Date(originVal)
  const y = dt.getFullYear()
  const m = (dt.getMonth()+1+'').padStart(2,'0')
  const d = (dt.getDate()+'').padStart(2,'0')

  const hh = (dt.getHours()+'').padStart(2,'0')
  const mm = (dt.getMinutes()+'').padStart(2,'0')
  const ss = (dt.getSeconds()+'').padStart(2,'0')

  return `${y}-${m}-${d} ${hh}:${mm}:${ss}`
})

new Vue({
  router,
  render: h =&gt; h(App)
}).$mount('#app')
</code></pre>
<hr>
<p>然后打开public/index.html添加外部cdn引入代码</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
    &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;
    &lt;title&gt;电商后台管理系统&lt;/title&gt;

    &lt;!-- nprogress 的样式表文件 --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css&quot; /&gt;
    &lt;!-- 富文本编辑器 的样式表文件 --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/quill/1.3.4/quill.core.min.css&quot; /&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/quill/1.3.4/quill.snow.min.css&quot; /&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/quill/1.3.4/quill.bubble.min.css&quot; /&gt;
    &lt;!-- element-ui 的样式表文件 --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/element-ui/2.8.2/theme-chalk/index.css&quot; /&gt;

    &lt;script src=&quot;https://cdn.staticfile.org/vue/2.5.22/vue.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.staticfile.org/vue-router/3.0.1/vue-router.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.staticfile.org/axios/0.18.0/axios.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.staticfile.org/lodash.js/4.17.11/lodash.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.staticfile.org/echarts/4.1.0/echarts.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js&quot;&gt;&lt;/script&gt;
    &lt;!-- 富文本编辑器的 js 文件 --&gt;
    &lt;script src=&quot;https://cdn.staticfile.org/quill/1.3.4/quill.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue-quill-editor@3.0.4/dist/vue-quill-editor.js&quot;&gt;&lt;/script&gt;

    &lt;!-- element-ui 的 js 文件 --&gt;
    &lt;script src=&quot;https://cdn.staticfile.org/element-ui/2.8.2/index.js&quot;&gt;&lt;/script&gt;

  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;
      &lt;strong&gt;We're sorry but vue_shop doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;
    &lt;/noscript&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
    &lt;!-- built files will be auto injected --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
</feed>